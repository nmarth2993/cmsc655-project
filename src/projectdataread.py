# -*- coding: utf-8 -*-
"""projectDataRead.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1d8LZlupdFETQ0hasl1VcxFtt2CYKWJkl
"""

import chess.pgn
import pandas as pd

def parse_pgn_file(file_path):
    games = []
    games_missing_headers = []

    with open(file_path, 'r') as f:
        while True:
            game = chess.pgn.read_game(f)
            if game is None:
                break

            # Check if the necessary headers are present
            if 'Result' not in game.headers or 'WhiteElo' not in game.headers or 'BlackElo' not in game.headers:
                games_missing_headers.append(game)
            else:
                games.append(game)

    return games, games_missing_headers

def create_dataset(games):
    data = []

    for game in games:
        board = game.board()

        # Get header information if available
        result = game.headers.get('Result')
        white_elo = int(game.headers.get('WhiteElo', 0))  # Default to 0 if not present
        black_elo = int(game.headers.get('BlackElo', 0))  # Default to 0 if not present

        previous_eval = None  # To store the previous evaluation

        for node in game.mainline():
            move = node.move
            move_san = board.san(move)
            move_number = board.ply()

            # Determine if the move was played by White or Black
            if board.turn == chess.WHITE:
                player = 'White'
            else:
                player = 'Black'

            # Get Stockfish evaluation from the comment after the move
            comment = node.comment
            stockfish_eval = float(comment.split(' ')[-1]) if comment else None

            # Calculate cp_loss (change in evaluation from the previous move)
            # (usually when centipawn loss is calculated it's always a positive number, but here it makes sense to keep negative centipawn loss for white if we're going w/ absolute_game_result like they did in the paper
            #
            cp_loss = stockfish_eval - previous_eval if previous_eval is not None else None

            # Update the previous_eval for the next iteration
            previous_eval = stockfish_eval

            # Determine the game result w/r/t the player who played the move
            # (1: player wins, 0.5: Draw, 0: opponent wins)
            # absolute_game_result is 1 if white wins, 0.5 draw, 0 if black wins
            # most likely absolute_game_result is the one we'll use, since it matches what they did in the paper
            if result == '1-0' and player == 'White':
                player_game_result = 1
                absolute_game_result = 1
            elif result == '1-0' and player == 'Black':
                player_game_result = 0
                absolute_game_result = 1
            elif result == '1/2-1/2':
                player_game_result = 0.5
                absolute_game_result = 0.5
            elif result == '0-1' and player == 'White':
                player_game_result = 0
                absolute_game_result = 0
            elif result == '0-1' and player == 'Black':
                player_game_result = 1
                absolute_game_result = 0
            else:  # there really shouldn't be an else if the pgns are all correct
                player_game_result = None

            data.append({
                'Move': move_san,
                'MoveNumber': move_number,
                'Player': player,
                'WhiteElo': white_elo,
                'BlackElo': black_elo,
                'GameResult': player_game_result,
                'AbsGameResult': absolute_game_result,
                'StockfishEval': stockfish_eval,
                'cp_loss': cp_loss
            })

            board.push(move)

    return pd.DataFrame(data)

pgn_file_path = 'drive/MyDrive/db2k.pgn' # just use whatever your path is to the pgn
games, games_missing_headers = parse_pgn_file(pgn_file_path)

# Create the dataset w/out the games with missing headers
dataset = create_dataset(games)
print(dataset.head())